<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders - 420360</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0d1b2a;
            --primary: #1b263b;
            --secondary: #415a77;
            --highlight: #778da9;
            --text: #e0e1dd;
            --danger: #d62828;
            --success: #06ffa5;
        }

        * { box-sizing: border-box; }
        html, body { 
            height: 100%; margin: 0; padding: 0; 
            background: var(--bg); color: var(--text); 
            font-family: 'Press Start 2P', 'Courier New', monospace; 
            image-rendering: pixelated; 
            display: flex; align-items: center; 
            justify-content: center; flex-direction: column; 
        }

        .game-container { text-align: center; padding: 20px; }
        h1 { 
            font-size: 24px; margin-bottom: 20px; 
            color: var(--primary); text-shadow: 2px 2px 0 var(--secondary); 
        }

        .game-stats { 
            display: flex; justify-content: space-around; 
            margin-bottom: 20px; font-size: 12px; 
            color: var(--highlight); max-width: 600px; 
        }
        .stat { 
            display: flex; flex-direction: column; 
            align-items: center; gap: 5px; 
        }
        .stat-value { font-size: 16px; color: var(--primary); }

        .game-board { 
            border: 4px solid var(--primary); 
            box-shadow: 0 0 0 4px var(--secondary), 8px 8px 0 0 var(--highlight), 0 0 0 8px #000; 
            background: #000; margin: 0 auto 20px auto; position: relative; 
        }

        .controls { 
            display: flex; flex-wrap: wrap; gap: 10px; 
            justify-content: center; margin-bottom: 20px; 
        }
        .btn { 
            background: var(--bg); border: 3px solid var(--primary); 
            color: var(--text); font-family: inherit; 
            font-size: 12px; padding: 10px 20px; 
            cursor: pointer; transition: all 0.2s; 
            box-shadow: 3px 3px 0 var(--secondary); 
        }
        .btn:hover { 
            background: var(--primary); color: var(--bg); 
            transform: translate(1px, 1px); 
            box-shadow: 2px 2px 0 var(--secondary); 
        }

        .instructions { 
            margin-top: 20px; font-size: 10px; 
            line-height: 1.6; max-width: 600px; color: var(--text); 
        }

        .mobile-controls { 
            display: none; position: fixed; bottom: 20px; left: 0; right: 0;
            justify-content: space-between; padding: 0 20px; 
            z-index: 1000; pointer-events: none;
        }
        .mobile-controls > * { pointer-events: auto; }
        
        .mobile-btn { 
            background: rgba(13, 27, 42, 0.9); border: 2px solid var(--primary); 
            color: var(--text); font-family: inherit; 
            font-size: 16px; padding: 20px; border-radius: 50%;
            cursor: pointer; transition: all 0.2s; 
            width: 70px; height: 70px; display: flex;
            align-items: center; justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            user-select: none; -webkit-user-select: none;
        }
        .mobile-btn:active { 
            background: var(--primary); color: var(--bg); 
            transform: scale(0.95); 
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); 
        }
        .mobile-btn.firing {
            background: var(--danger);
            border-color: var(--danger);
            animation: pulse 0.2s ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .mobile-movement {
            display: flex; gap: 15px;
        }
        
        .shoot-btn {
            background: rgba(214, 40, 40, 0.9) !important;
            border-color: var(--danger) !important;
            font-size: 18px !important;
        }

        .game-message { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            background: var(--bg); border: 4px solid var(--primary); 
            padding: 20px; text-align: center; 
            box-shadow: 0 0 0 4px var(--secondary), 8px 8px 0 0 var(--highlight); 
            display: none; z-index: 100; 
        }
        .game-message h2 { 
            color: var(--primary); font-size: 16px; margin: 0 0 10px 0; 
        }
        .game-message p { font-size: 10px; margin: 10px 0; }

        .win-message { border-color: var(--success); }
        .win-message h2 { color: var(--success); }

        @media (max-width: 768px) { 
            .mobile-controls { display: flex; } 
            .instructions { font-size: 8px; } 
            h1 { font-size: 18px; } 
            .game-stats { font-size: 10px; } 
            .stat-value { font-size: 14px; }
            .game-board { margin: 0 auto 80px auto; } /* Space for mobile controls */
            .controls { margin-bottom: 10px; }
        }

        .header { 
            width: 100%; text-align: center; 
            padding: 15px 0; background: var(--bg); 
            border-bottom: 3px solid var(--primary); margin-bottom: 20px; 
        }
        .back-link { 
            color: var(--primary); text-decoration: none; 
            font-size: 10px; transition: all 0.2s; 
            display: inline-block; padding: 8px 15px; 
            border: 2px solid var(--primary); background: var(--bg); 
            box-shadow: 2px 2px 0 var(--secondary); 
        }
        .back-link:hover { 
            background: var(--primary); color: var(--bg); 
            transform: translate(1px, 1px); 
            box-shadow: 1px 1px 0 var(--secondary); 
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="../index.html" class="back-link" aria-label="Back to Games">‚Üê Back to Games</a>
    </header>

    <div class="game-container">
        <h1>SPACE INVADERS</h1>
        
        <div class="game-stats">
            <div class="stat">
                <div>Score</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat">
                <div>High Score</div>
                <div class="stat-value" id="highScore">0</div>
            </div>
            <div class="stat">
                <div>Lives</div>
                <div class="stat-value" id="lives">3</div>
            </div>
            <div class="stat">
                <div>Wave</div>
                <div class="stat-value" id="wave">1</div>
            </div>
        </div>
        
        <div class="game-board">
            <canvas id="gameCanvas" width="600" height="500"></canvas>
            <div id="gameOver" class="game-message">
                <h2>GAME OVER</h2>
                <p>Final Score: <span id="finalScore">0</span></p>
                <button class="btn" onclick="startGame()">PLAY AGAIN</button>
            </div>
            <div id="gameWin" class="game-message win-message">
                <h2>WAVE CLEARED!</h2>
                <p>Score: <span id="waveScore">0</span></p>
                <button class="btn" onclick="nextWave()">NEXT WAVE</button>
            </div>
        </div>
        
        <div class="controls">
            <button id="startBtn" class="btn" onclick="startGame()">START GAME</button>
            <button class="btn" onclick="pauseGame()">PAUSE</button>
        </div>
        
        <div class="mobile-controls">
            <div class="mobile-movement">
                <button id="moveLeftBtn" class="mobile-btn">‚Üê</button>
                <button id="moveRightBtn" class="mobile-btn">‚Üí</button>
            </div>
            <button id="shootBtn" class="mobile-btn shoot-btn">üöÄ</button>
        </div>
        
        <div class="instructions">
            <p><strong>How to Play:</strong></p>
            <p>‚Ä¢ Use ARROW KEYS or A/D to move left/right</p>
            <p>‚Ä¢ Press SPACE to shoot (or hold üöÄ for rapid fire)</p>
            <p>‚Ä¢ Collect power-ups: ‚ö°Spread Shot, üõ°Ô∏èShield, üî•Piercing, üí•Rapid Fire</p>
            <p>‚Ä¢ Destroy all aliens to advance ‚Ä¢ Boss battles every 5 waves!</p>
            <p>‚Ä¢ Build combos for score multipliers ‚Ä¢ Use barriers as cover</p>
            <p>‚Ä¢ Don't let aliens reach the bottom!</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const livesElement = document.getElementById('lives');
        const waveElement = document.getElementById('wave');
        const finalScoreElement = document.getElementById('finalScore');
        const waveScoreElement = document.getElementById('waveScore');
        const gameOverElement = document.getElementById('gameOver');
        const gameWinElement = document.getElementById('gameWin');

        // Game variables
        let gameRunning = false;
        let gameLoop = null;
        let score = 0;
        let lives = 3;
        let wave = 1;
        let highScore = localStorage.getItem('spaceInvadersHighScore') || 0;
        highScoreElement.textContent = highScore;

        // Alien shooting system - structured patterns instead of random chaos
        let alienShootingSystem = {
            lastShootTime: 0,
            shootInterval: 1000, // Base interval between shots in milliseconds
            activeShooters: [],
            patternIndex: 0,
            maxBulletsOnScreen: 8, // Limit concurrent alien bullets
            
            // Different shooting patterns for each wave
            patterns: {
                // Wave 1-2: Simple column shooting
                'column': {
                    name: 'Column Sweep',
                    interval: 1200,
                    maxBullets: 6,
                    selectShooters: (aliens) => {
                        // Only bottom-most alien in each column shoots
                        const columns = {};
                        aliens.forEach(alien => {
                            const col = Math.floor(alien.x / 60);
                            if (!columns[col] || alien.y > columns[col].y) {
                                columns[col] = alien;
                            }
                        });
                        return Object.values(columns).slice(0, 2); // Max 2 shooters
                    }
                },
                
                // Wave 3-4: Alternating pattern
                'alternating': {
                    name: 'Alternating Fire',
                    interval: 800,
                    maxBullets: 8,
                    selectShooters: (aliens) => {
                        // Alternate between left and right sides
                        const leftSide = aliens.filter(a => a.x < canvas.width / 2);
                        const rightSide = aliens.filter(a => a.x >= canvas.width / 2);
                        const shooters = [];
                        
                        if (alienShootingSystem.patternIndex % 2 === 0 && leftSide.length > 0) {
                            shooters.push(leftSide[Math.floor(Math.random() * leftSide.length)]);
                        } else if (rightSide.length > 0) {
                            shooters.push(rightSide[Math.floor(Math.random() * rightSide.length)]);
                        }
                        
                        return shooters;
                    }
                },
                
                // Wave 5+: Strategic targeting
                'targeting': {
                    name: 'Targeted Fire',
                    interval: 600,
                    maxBullets: 10,
                    selectShooters: (aliens) => {
                        // Target aliens closest to player's horizontal position
                        const playerCenter = player.x + player.width / 2;
                        const sorted = aliens.sort((a, b) => {
                            const aDist = Math.abs((a.x + a.width/2) - playerCenter);
                            const bDist = Math.abs((b.x + b.width/2) - playerCenter);
                            return aDist - bDist;
                        });
                        
                        // Select 1-3 closest aliens with some randomness
                        const numShooters = Math.min(2 + Math.floor(wave / 3), 3);
                        return sorted.slice(0, numShooters).filter(() => Math.random() < 0.7);
                    }
                }
            }
        };

        // Mobile controls state
        let mobileControls = {
            leftPressed: false,
            rightPressed: false,
            shootPressed: false,
            shootInterval: null,
            rapidFireRate: 100 // milliseconds between shots when holding
        };

        // Player object
        const player = {
            x: canvas.width / 2 - 20,
            y: canvas.height - 40,
            width: 40,
            height: 20,
            speed: 5
        };

        // Game arrays
        let bullets = [];
        let aliens = [];
        let alienBullets = [];
        let powerUps = [];
        let particles = [];
        let boss = null;
        let barriers = [];

        // Power-up system
        const POWER_UP_TYPES = {
            SPREAD_SHOT: { 
                name: 'Spread Shot', 
                color: '#00fff7', 
                icon: '‚ö°', 
                duration: 10000,
                description: 'Triple shot spread'
            },
            SHIELD: { 
                name: 'Shield', 
                color: '#06ffa5', 
                icon: 'üõ°Ô∏è', 
                duration: 15000,
                description: 'Temporary invincibility'
            },
            PIERCING: { 
                name: 'Piercing Laser', 
                color: '#ff00ea', 
                icon: 'üî•', 
                duration: 12000,
                description: 'Bullets pierce through enemies'
            },
            RAPID_FIRE: { 
                name: 'Rapid Fire', 
                color: '#fff700', 
                icon: 'üí•', 
                duration: 8000,
                description: 'Increased fire rate'
            }
        };

        // Player power-up state
        let playerPowerUps = {
            spreadShot: { active: false, endTime: 0 },
            shield: { active: false, endTime: 0 },
            piercing: { active: false, endTime: 0 },
            rapidFire: { active: false, endTime: 0 }
        };

        // Combo system
        let comboSystem = {
            count: 0,
            multiplier: 1,
            lastHitTime: 0,
            comboTimeWindow: 1000 // 1 second to maintain combo
        };

        // Boss system
        const BOSS_TYPES = {
            MOTHER_SHIP: {
                health: 50,
                maxHealth: 50,
                width: 120,
                height: 60,
                color: '#ff0040',
                points: 1000,
                attackPatterns: ['laser_sweep', 'missile_barrage', 'teleport_attack'],
                weakPoints: [
                    { x: 30, y: 20, width: 20, height: 20, health: 10 },
                    { x: 70, y: 20, width: 20, height: 20, health: 10 }
                ]
            }
        };

        // Barrier system for dynamic environments
        function createBarriers() {
            barriers = [];
            for (let i = 0; i < 4; i++) {
                barriers.push({
                    x: 100 + i * 120,
                    y: canvas.height - 150,
                    width: 60,
                    height: 40,
                    health: 5,
                    maxHealth: 5,
                    moving: wave >= 5, // Moving barriers on wave 5+
                    direction: Math.random() > 0.5 ? 1 : -1,
                    speed: 1
                });
            }
        }

        // Alien grid
        const alienRows = 5;
        const alienCols = 10;
        const alienSize = 30;
        const alienSpacing = 40;
        let alienDirection = 1;
        let alienSpeed = 1;

        // Enemy types - shootChance values are legacy, now using structured patterns
        const ENEMY_TYPES = {
            BASIC: { 
                health: 1, 
                points: 10, 
                color: '#ff00ea', 
                behavior: 'normal'
            },
            SHIELDED: { 
                health: 3, 
                points: 30, 
                color: '#06ffa5', 
                behavior: 'normal',
                shield: true
            },
            DODGER: { 
                health: 1, 
                points: 20, 
                color: '#fff700', 
                behavior: 'dodge',
                dodgeSpeed: 2
            },
            SPLITTER: { 
                health: 2, 
                points: 25, 
                color: '#ff0040', 
                behavior: 'split',
                splitCount: 2
            }
        };

        // Colors matching the retro theme
        const COLORS = {
            player: '#fff700',
            bullet: '#00fff7',
            alien: '#ff00ea',
            alienBullet: '#ff0040',
            background: '#000000'
        };

        function startGame() {
            // Enable audio on first user interaction
            if (typeof GameSounds !== 'undefined') {
                GameSounds.enableAudio();
            }
            
            // Reset game state
            player.x = canvas.width / 2 - 20;
            bullets = [];
            alienBullets = [];
            powerUps = [];
            particles = [];
            boss = null;
            score = 0;
            lives = 3;
            wave = 1;
            gameRunning = true;
            gameOverElement.style.display = 'none';
            gameWinElement.style.display = 'none';
            
            // Reset alien shooting system
            alienShootingSystem.lastShootTime = 0;
            alienShootingSystem.patternIndex = 0;
            alienShootingSystem.shootInterval = 1000;
            alienShootingSystem.maxBulletsOnScreen = 8;
            
            // Reset power-ups
            Object.keys(playerPowerUps).forEach(key => {
                playerPowerUps[key].active = false;
                playerPowerUps[key].endTime = 0;
            });
            
            // Reset combo system
            comboSystem.count = 0;
            comboSystem.multiplier = 1;
            comboSystem.lastHitTime = 0;
            
            createAliens();
            createBarriers();
            updateDisplay();
            
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, 1000/60); // 60 FPS
            
            // Play game start sound
            if (typeof GameSounds !== 'undefined' && GameSounds.isEnabled()) {
                GameSounds.sounds.GAME_START();
            }
            
            document.getElementById('startBtn').textContent = 'RESTART';
        }

        function createAliens() {
            aliens = [];
            const startX = (canvas.width - (alienCols * alienSpacing)) / 2;
            const startY = 50;
            
            for (let row = 0; row < alienRows; row++) {
                for (let col = 0; col < alienCols; col++) {
                    // Determine enemy type based on row and wave
                    let enemyType = ENEMY_TYPES.BASIC;
                    
                    if (wave >= 3 && row === 0) {
                        // Top row gets special enemies on wave 3+
                        if (col % 3 === 0) enemyType = ENEMY_TYPES.SHIELDED;
                        else if (col % 3 === 1) enemyType = ENEMY_TYPES.DODGER;
                        else enemyType = ENEMY_TYPES.SPLITTER;
                    } else if (wave >= 2 && row === 1) {
                        // Second row gets dodgers on wave 2+
                        if (col % 2 === 0) enemyType = ENEMY_TYPES.DODGER;
                    }
                    
                    aliens.push({
                        x: startX + col * alienSpacing,
                        y: startY + row * alienSpacing,
                        width: alienSize,
                        height: alienSize,
                        points: enemyType.points + (4 - row) * 5,
                        type: enemyType,
                        health: enemyType.health,
                        maxHealth: enemyType.health,
                        lastDodgeTime: 0,
                        dodgeDirection: Math.random() > 0.5 ? 1 : -1
                    });
                }
            }
        }

        function pauseGame() {
            if (gameRunning) {
                gameRunning = false;
                clearInterval(gameLoop);
            } else if (gameLoop) {
                gameRunning = true;
                gameLoop = setInterval(update, 1000/60);
            }
        }

        function shoot() {
            if (!gameRunning) return;
            
            // Play shooting sound
            if (typeof GameSounds !== 'undefined' && GameSounds.isEnabled()) {
                GameSounds.sounds.BUTTON_CLICK();
            }
            
            // Check for rapid fire power-up
            const fireRate = playerPowerUps.rapidFire.active ? 50 : 
                           (mobileControls.rapidFireRate || 100);
            
            // Prevent shooting too quickly (except with rapid fire)
            const now = Date.now();
            if (!playerPowerUps.rapidFire.active && 
                bullets.length > 0 && 
                now - bullets[bullets.length - 1].createdTime < fireRate) {
                return;
            }
            
            if (playerPowerUps.spreadShot.active) {
                // Spread shot - fire 3 bullets
                for (let i = -1; i <= 1; i++) {
                    bullets.push({
                        x: player.x + player.width / 2 - 2,
                        y: player.y,
                        width: 4,
                        height: 10,
                        speed: 7,
                        angle: i * 0.3, // Spread angle
                        piercing: playerPowerUps.piercing.active,
                        createdTime: now
                    });
                }
            } else {
                // Normal shot
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    width: 4,
                    height: 10,
                    speed: 7,
                    angle: 0,
                    piercing: playerPowerUps.piercing.active,
                    createdTime: now
                });
            }
        }

        function movePlayer(direction) {
            if (!gameRunning) return;
            
            player.x += direction * player.speed;
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
        }

        function update() {
            if (!gameRunning) return;
            
            const currentTime = Date.now();
            
            // Update power-ups
            updatePowerUps(currentTime);
            
            // Update combo system
            updateComboSystem(currentTime);
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Move bullet with angle (for spread shot)
                bullet.y -= bullet.speed;
                if (bullet.angle) {
                    bullet.x += Math.sin(bullet.angle) * bullet.speed * 0.5;
                }
                
                // Remove bullets that go off screen
                if (bullet.y < 0 || bullet.x < 0 || bullet.x > canvas.width) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with barriers
                let bulletHitBarrier = false;
                for (const barrier of barriers) {
                    if (barrier.health > 0 &&
                        bullet.x < barrier.x + barrier.width &&
                        bullet.x + bullet.width > barrier.x &&
                        bullet.y < barrier.y + barrier.height &&
                        bullet.y + bullet.height > barrier.y) {
                        
                        barrier.health--;
                        if (!bullet.piercing) {
                            bullets.splice(i, 1);
                            bulletHitBarrier = true;
                            break;
                        }
                    }
                }
                
                if (bulletHitBarrier) continue;
                
                // Check collision with boss
                if (boss && bullet.x < boss.x + boss.width &&
                    bullet.x + bullet.width > boss.x &&
                    bullet.y < boss.y + boss.height &&
                    bullet.y + bullet.height > boss.y) {
                    
                    // Check weak points first
                    let hitWeakPoint = false;
                    for (const weakPoint of boss.weakPoints) {
                        if (!weakPoint.destroyed &&
                            bullet.x < boss.x + weakPoint.x + weakPoint.width &&
                            bullet.x + bullet.width > boss.x + weakPoint.x &&
                            bullet.y < boss.y + weakPoint.y + weakPoint.height &&
                            bullet.y + bullet.height > boss.y + weakPoint.y) {
                            
                            weakPoint.health--;
                            if (weakPoint.health <= 0) {
                                weakPoint.destroyed = true;
                                boss.health -= 10; // Extra damage for destroying weak point
                            }
                            boss.health--;
                            hitWeakPoint = true;
                            break;
                        }
                    }
                    
                    if (!hitWeakPoint) {
                        boss.health--; // Normal damage to boss body
                    }
                    
                    // Handle combo and scoring
                    comboSystem.count++;
                    comboSystem.lastHitTime = currentTime;
                    comboSystem.multiplier = 1 + (comboSystem.count * 0.1);
                    
                    const baseScore = hitWeakPoint ? 100 : 50;
                    score += Math.floor(baseScore * comboSystem.multiplier);
                    
                    // Create hit particles
                    createHitParticles(bullet.x, bullet.y, boss.color);
                    
                    if (boss.health <= 0) {
                        // Boss defeated
                        score += Math.floor(boss.points * comboSystem.multiplier);
                        createHitParticles(boss.x + boss.width/2, boss.y + boss.height/2, boss.color);
                        
                        // Drop multiple power-ups
                        for (let j = 0; j < 3; j++) {
                            const powerUpTypes = Object.keys(POWER_UP_TYPES);
                            const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                            
                            powerUps.push({
                                x: boss.x + (j * 30) + 30,
                                y: boss.y + boss.height / 2,
                                width: 20,
                                height: 20,
                                type: randomType,
                                data: POWER_UP_TYPES[randomType],
                                fallSpeed: 2
                            });
                        }
                        
                        boss = null;
                        
                        if (typeof GameSounds !== 'undefined' && GameSounds.isEnabled()) {
                            GameSounds.sounds.LEVEL_UP();
                        }
                    }
                    
                    if (!bullet.piercing) {
                        bullets.splice(i, 1);
                        continue;
                    }
                }
                
                // Check collision with aliens
                for (let j = aliens.length - 1; j >= 0; j--) {
                    const alien = aliens[j];
                    if (bullet.x < alien.x + alien.width &&
                        bullet.x + bullet.width > alien.x &&
                        bullet.y < alien.y + alien.height &&
                        bullet.y + bullet.height > alien.y) {
                        
                        // Damage alien
                        alien.health--;
                        
                        // Handle combo system
                        comboSystem.count++;
                        comboSystem.lastHitTime = currentTime;
                        comboSystem.multiplier = 1 + (comboSystem.count * 0.1);
                        
                        // Calculate score with combo multiplier
                        const baseScore = alien.points * (alien.maxHealth - alien.health + 1);
                        score += Math.floor(baseScore * comboSystem.multiplier);
                        
                        // Create hit particle effect
                        createHitParticles(alien.x + alien.width/2, alien.y + alien.height/2, alien.type.color);
                        
                        if (alien.health <= 0) {
                            // Handle enemy death
                            handleAlienDeath(alien, j);
                            
                            // Play alien destruction sound
                            if (typeof GameSounds !== 'undefined' && GameSounds.isEnabled()) {
                                GameSounds.sounds.BREAK();
                            }
                        }
                        
                        // Remove bullet if not piercing
                        if (!bullet.piercing) {
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            // Update power-up items
            updatePowerUpItems();
            
            // Update alien bullets
            for (let i = alienBullets.length - 1; i >= 0; i--) {
                const bullet = alienBullets[i];
                
                // Handle special bullet types
                if (bullet.homing && bullet.target) {
                    // Simple homing logic
                    const dx = bullet.target.x - bullet.x;
                    bullet.x += Math.sign(dx) * 0.5;
                }
                
                if (bullet.angle) {
                    bullet.x += Math.sin(bullet.angle) * bullet.speed * 0.5;
                }
                
                bullet.y += bullet.speed;
                
                // Remove bullets that go off screen
                if (bullet.y > canvas.height || bullet.x < 0 || bullet.x > canvas.width) {
                    alienBullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with barriers
                for (const barrier of barriers) {
                    if (barrier.health > 0 &&
                        bullet.x < barrier.x + barrier.width &&
                        bullet.x + bullet.width > barrier.x &&
                        bullet.y < barrier.y + barrier.height &&
                        bullet.y + bullet.height > barrier.y) {
                        
                        barrier.health--;
                        alienBullets.splice(i, 1);
                        break;
                    }
                }
                
                // Check collision with player (unless shielded)
                if (!playerPowerUps.shield.active &&
                    bullet.x < player.x + player.width &&
                    bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height &&
                    bullet.y + bullet.height > player.y) {
                    
                    // Play hit sound
                    if (typeof GameSounds !== 'undefined' && GameSounds.isEnabled()) {
                        GameSounds.sounds.HIT();
                    }
                    
                    lives--;
                    alienBullets.splice(i, 1);
                    
                    // Reset combo on hit
                    comboSystem.count = 0;
                    comboSystem.multiplier = 1;
                    
                    if (lives <= 0) {
                        gameOver();
                        return;
                    }
                }
            }
            
            // Move aliens with behaviors
            updateAlienMovement(currentTime);
            
            // Update boss
            if (boss) {
                updateBoss(currentTime);
            }
            
            // Update barriers
            updateBarriers();
            
            // Structured alien shooting system
            updateAlienShooting(currentTime);
            
            // Update particles
            updateParticles();
            
            // Check win condition
            if (!boss && aliens.length === 0) {
                waveWin();
                return;
            } else if (boss && boss.health <= 0) {
                boss = null; // Boss already handled in bullet collision
                waveWin();
                return;
            }
            
            updateDisplay();
            draw();
        }

        function updateAlienShooting(currentTime) {
            // Limit the number of alien bullets on screen
            if (alienBullets.length >= alienShootingSystem.maxBulletsOnScreen) {
                return;
            }
            
            // Check if it's time to shoot
            if (currentTime - alienShootingSystem.lastShootTime < alienShootingSystem.shootInterval) {
                return;
            }
            
            // Select appropriate pattern based on wave
            let patternKey = 'column';
            if (wave >= 5) {
                patternKey = 'targeting';
            } else if (wave >= 3) {
                patternKey = 'alternating';
            }
            
            const pattern = alienShootingSystem.patterns[patternKey];
            
            // Update interval and max bullets based on wave
            alienShootingSystem.shootInterval = Math.max(300, pattern.interval - (wave * 50));
            alienShootingSystem.maxBulletsOnScreen = Math.min(15, pattern.maxBullets + Math.floor(wave / 2));
            
            // Select shooters using the pattern
            if (aliens.length > 0) {
                const shooters = pattern.selectShooters(aliens);
                
                // Create bullets from selected shooters
                shooters.forEach(alien => {
                    if (alienBullets.length < alienShootingSystem.maxBulletsOnScreen) {
                        alienBullets.push({
                            x: alien.x + alien.width / 2 - 2,
                            y: alien.y + alien.height,
                            width: 4,
                            height: 8,
                            speed: 3 + Math.floor(wave / 3), // Speed increases with wave
                            pattern: patternKey
                        });
                    }
                });
                
                alienShootingSystem.lastShootTime = currentTime;
                alienShootingSystem.patternIndex++;
            }
        }

        function updatePowerUps(currentTime) {
            // Check and deactivate expired power-ups
            Object.keys(playerPowerUps).forEach(key => {
                if (playerPowerUps[key].active && currentTime > playerPowerUps[key].endTime) {
                    playerPowerUps[key].active = false;
                }
            });
        }

        function updateComboSystem(currentTime) {
            // Reset combo if too much time has passed
            if (currentTime - comboSystem.lastHitTime > comboSystem.comboTimeWindow) {
                comboSystem.count = 0;
                comboSystem.multiplier = 1;
            }
        }

        function handleAlienDeath(alien, index) {
            // Handle special enemy behaviors on death
            if (alien.type.behavior === 'split' && alien.type.splitCount > 0) {
                // Create smaller aliens
                for (let i = 0; i < alien.type.splitCount; i++) {
                    const newAlien = {
                        x: alien.x + (i * 15) - 15,
                        y: alien.y,
                        width: alienSize * 0.7,
                        height: alienSize * 0.7,
                        points: Math.floor(alien.points * 0.3),
                        type: ENEMY_TYPES.BASIC,
                        health: 1,
                        maxHealth: 1,
                        lastDodgeTime: 0,
                        dodgeDirection: Math.random() > 0.5 ? 1 : -1
                    };
                    aliens.push(newAlien);
                }
            }
            
            // Chance to drop power-up
            if (Math.random() < 0.15) { // 15% chance
                const powerUpTypes = Object.keys(POWER_UP_TYPES);
                const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                
                powerUps.push({
                    x: alien.x + alien.width / 2 - 10,
                    y: alien.y + alien.height / 2 - 10,
                    width: 20,
                    height: 20,
                    type: randomType,
                    data: POWER_UP_TYPES[randomType],
                    fallSpeed: 2
                });
            }
            
            aliens.splice(index, 1);
        }

        function updateAlienMovement(currentTime) {
            let changeDirection = false;
            
            for (const alien of aliens) {
                // Apply special behaviors
                if (alien.type.behavior === 'dodge') {
                    // Dodger behavior - occasional quick movements
                    if (currentTime - alien.lastDodgeTime > 2000 + Math.random() * 3000) {
                        alien.x += alien.dodgeDirection * alien.type.dodgeSpeed * 10;
                        alien.dodgeDirection *= -1;
                        alien.lastDodgeTime = currentTime;
                    }
                }
                
                // Normal movement
                alien.x += alienDirection * alienSpeed;
                
                if (alien.x <= 0 || alien.x >= canvas.width - alien.width) {
                    changeDirection = true;
                }
            }
            
            if (changeDirection) {
                alienDirection *= -1;
                for (const alien of aliens) {
                    alien.y += 20;
                    // Check if aliens reached bottom
                    if (alien.y >= player.y) {
                        gameOver();
                        return;
                    }
                }
            }
        }

        function updatePowerUpItems() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.fallSpeed;
                
                // Remove if off screen
                if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (powerUp.x < player.x + player.width &&
                    powerUp.x + powerUp.width > player.x &&
                    powerUp.y < player.y + player.height &&
                    powerUp.y + powerUp.height > player.y) {
                    
                    // Activate power-up
                    activatePowerUp(powerUp.type);
                    powerUps.splice(i, 1);
                    
                    // Play power-up sound
                    if (typeof GameSounds !== 'undefined' && GameSounds.isEnabled()) {
                        GameSounds.sounds.LEVEL_UP();
                    }
                }
            }
        }

        function activatePowerUp(type) {
            const currentTime = Date.now();
            const powerUpData = POWER_UP_TYPES[type];
            
            switch(type) {
                case 'SPREAD_SHOT':
                    playerPowerUps.spreadShot.active = true;
                    playerPowerUps.spreadShot.endTime = currentTime + powerUpData.duration;
                    break;
                case 'SHIELD':
                    playerPowerUps.shield.active = true;
                    playerPowerUps.shield.endTime = currentTime + powerUpData.duration;
                    break;
                case 'PIERCING':
                    playerPowerUps.piercing.active = true;
                    playerPowerUps.piercing.endTime = currentTime + powerUpData.duration;
                    break;
                case 'RAPID_FIRE':
                    playerPowerUps.rapidFire.active = true;
                    playerPowerUps.rapidFire.endTime = currentTime + powerUpData.duration;
                    break;
            }
        }

        function createHitParticles(x, y, color) {
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 30,
                    maxLife: 30,
                    color: color
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function updateBoss(currentTime) {
            // Boss movement
            boss.x += boss.movement.direction * boss.movement.speed;
            
            // Boundary check
            if (boss.x <= 0 || boss.x >= canvas.width - boss.width) {
                boss.movement.direction *= -1;
            }
            
            // Boss attacks
            boss.attackTimer += 16; // Roughly 60 FPS
            
            if (boss.attackTimer >= boss.attackCooldown) {
                performBossAttack();
                boss.attackTimer = 0;
                boss.currentAttack = (boss.currentAttack + 1) % 3;
            }
        }

        function performBossAttack() {
            switch (boss.currentAttack) {
                case 0: // Laser sweep
                    for (let i = 0; i < 5; i++) {
                        alienBullets.push({
                            x: boss.x + (i * 25) + 10,
                            y: boss.y + boss.height,
                            width: 6,
                            height: 12,
                            speed: 4
                        });
                    }
                    break;
                    
                case 1: // Missile barrage
                    for (let i = 0; i < 3; i++) {
                        alienBullets.push({
                            x: boss.x + boss.width / 2 - 3,
                            y: boss.y + boss.height,
                            width: 6,
                            height: 15,
                            speed: 2 + i,
                            homing: true,
                            target: player
                        });
                    }
                    break;
                    
                case 2: // Spread attack
                    for (let i = -2; i <= 2; i++) {
                        alienBullets.push({
                            x: boss.x + boss.width / 2 - 2,
                            y: boss.y + boss.height,
                            width: 4,
                            height: 10,
                            speed: 3,
                            angle: i * 0.5
                        });
                    }
                    break;
            }
        }

        function updateBarriers() {
            for (const barrier of barriers) {
                if (barrier.moving && barrier.health > 0) {
                    barrier.x += barrier.direction * barrier.speed;
                    
                    // Boundary check for moving barriers
                    if (barrier.x <= 0 || barrier.x >= canvas.width - barrier.width) {
                        barrier.direction *= -1;
                    }
                }
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw player with shield effect
            if (playerPowerUps.shield.active) {
                ctx.fillStyle = '#06ffa5';
                ctx.globalAlpha = 0.3;
                ctx.fillRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
                ctx.globalAlpha = 1;
            }
            
            ctx.fillStyle = COLORS.player;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            // Draw bullets with effects
            bullets.forEach(bullet => {
                if (bullet.piercing) {
                    ctx.fillStyle = '#ff00ea';
                } else if (playerPowerUps.spreadShot.active) {
                    ctx.fillStyle = '#00fff7';
                } else {
                    ctx.fillStyle = COLORS.bullet;
                }
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
            
            // Draw alien bullets
            ctx.fillStyle = COLORS.alienBullet;
            alienBullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
            
            // Draw aliens with health indication
            aliens.forEach(alien => {
                // Main alien body
                ctx.fillStyle = alien.type.color;
                ctx.fillRect(alien.x, alien.y, alien.width, alien.height);
                
                // Health bar for damaged enemies
                if (alien.health < alien.maxHealth) {
                    const barWidth = alien.width;
                    const barHeight = 3;
                    const healthRatio = alien.health / alien.maxHealth;
                    
                    // Background
                    ctx.fillStyle = '#333';
                    ctx.fillRect(alien.x, alien.y - 8, barWidth, barHeight);
                    
                    // Health
                    ctx.fillStyle = healthRatio > 0.5 ? '#06ffa5' : '#d62828';
                    ctx.fillRect(alien.x, alien.y - 8, barWidth * healthRatio, barHeight);
                }
                
                // Shield effect for shielded enemies
                if (alien.type.shield && alien.health === alien.maxHealth) {
                    ctx.fillStyle = '#06ffa5';
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(alien.x - 2, alien.y - 2, alien.width + 4, alien.height + 4);
                    ctx.globalAlpha = 1;
                }
                
                // Add alien highlights
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(alien.x, alien.y, 2, 2);
                ctx.fillRect(alien.x + alien.width - 2, alien.y, 2, 2);
            });
            
            // Draw power-ups
            powerUps.forEach(powerUp => {
                ctx.fillStyle = powerUp.data.color;
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                
                // Draw icon
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(powerUp.data.icon, powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2 + 6);
            });
            
            // Draw barriers
            barriers.forEach(barrier => {
                if (barrier.health > 0) {
                    const healthRatio = barrier.health / barrier.maxHealth;
                    ctx.fillStyle = healthRatio > 0.5 ? '#415a77' : '#778da9';
                    ctx.fillRect(barrier.x, barrier.y, barrier.width, barrier.height);
                    
                    // Draw damage cracks
                    if (healthRatio < 1) {
                        ctx.fillStyle = '#000';
                        for (let i = 0; i < (5 - barrier.health); i++) {
                            const crackX = barrier.x + Math.random() * barrier.width;
                            const crackY = barrier.y + Math.random() * barrier.height;
                            ctx.fillRect(crackX, crackY, 3, 3);
                        }
                    }
                }
            });
            
            // Draw boss
            if (boss) {
                // Main boss body
                ctx.fillStyle = boss.color;
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                
                // Boss health bar
                const healthBarWidth = boss.width;
                const healthBarHeight = 8;
                const healthRatio = boss.health / boss.maxHealth;
                
                // Background
                ctx.fillStyle = '#333';
                ctx.fillRect(boss.x, boss.y - 15, healthBarWidth, healthBarHeight);
                
                // Health
                ctx.fillStyle = healthRatio > 0.5 ? '#06ffa5' : '#d62828';
                ctx.fillRect(boss.x, boss.y - 15, healthBarWidth * healthRatio, healthBarHeight);
                
                // Draw weak points
                boss.weakPoints.forEach(weakPoint => {
                    if (!weakPoint.destroyed) {
                        ctx.fillStyle = '#fff700';
                        ctx.fillRect(boss.x + weakPoint.x, boss.y + weakPoint.y, weakPoint.width, weakPoint.height);
                        
                        // Weak point health indicator
                        if (weakPoint.health < 10) {
                            ctx.fillStyle = '#ff0040';
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(weakPoint.health, boss.x + weakPoint.x + weakPoint.width/2, boss.y + weakPoint.y + weakPoint.height/2 + 4);
                        }
                    }
                });
                
                // Boss decorations
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(boss.x + 10, boss.y + 10, 4, 4);
                ctx.fillRect(boss.x + boss.width - 14, boss.y + 10, 4, 4);
            }
            
            // Draw particles
            particles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = alpha;
                ctx.fillRect(particle.x, particle.y, 2, 2);
            });
            ctx.globalAlpha = 1;
            
            // Draw UI overlays
            drawPowerUpIndicators();
            drawComboIndicator();
        }

        function drawPowerUpIndicators() {
            let yPos = 10;
            const currentTime = Date.now();
            
            Object.keys(playerPowerUps).forEach(key => {
                if (playerPowerUps[key].active) {
                    const powerUp = playerPowerUps[key];
                    const timeLeft = powerUp.endTime - currentTime;
                    const totalTime = POWER_UP_TYPES[key.toUpperCase()].duration;
                    const ratio = timeLeft / totalTime;
                    
                    // Background
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(10, yPos, 150, 20);
                    
                    // Progress bar
                    ctx.fillStyle = POWER_UP_TYPES[key.toUpperCase()].color;
                    ctx.fillRect(10, yPos, 150 * ratio, 20);
                    
                    // Text
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(POWER_UP_TYPES[key.toUpperCase()].name, 15, yPos + 15);
                    
                    yPos += 25;
                }
            });
        }

        function drawComboIndicator() {
            if (comboSystem.count > 1) {
                ctx.fillStyle = '#fff700';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`COMBO x${comboSystem.count}`, canvas.width / 2, 30);
                ctx.fillText(`${Math.floor(comboSystem.multiplier * 100)}% BONUS`, canvas.width / 2, 50);
            }
        }

        function waveWin() {
            gameRunning = false;
            clearInterval(gameLoop);
            
            // Play wave completion sound
            if (typeof GameSounds !== 'undefined' && GameSounds.isEnabled()) {
                GameSounds.sounds.LEVEL_UP();
            }
            
            waveScoreElement.textContent = score;
            gameWinElement.style.display = 'block';
        }

        function nextWave() {
            wave++;
            alienSpeed += 0.3; // Gradual difficulty increase
            
            // Reset alien shooting system for new wave
            alienShootingSystem.lastShootTime = 0;
            alienShootingSystem.patternIndex = 0;
            
            // Create barriers for new wave
            createBarriers();
            
            // Boss waves every 5 waves
            if (wave % 5 === 0) {
                createBoss();
            } else {
                createAliens();
            }
            
            gameWinElement.style.display = 'none';
            gameRunning = true;
            gameLoop = setInterval(update, 1000/60);
        }

        function createBoss() {
            const bossType = BOSS_TYPES.MOTHER_SHIP;
            boss = {
                x: canvas.width / 2 - bossType.width / 2,
                y: 50,
                width: bossType.width,
                height: bossType.height,
                health: bossType.health,
                maxHealth: bossType.maxHealth,
                color: bossType.color,
                points: bossType.points,
                attackTimer: 0,
                attackCooldown: 2000, // 2 seconds between attacks
                currentAttack: 0,
                weakPoints: bossType.weakPoints.map(wp => ({...wp, destroyed: false})),
                movement: {
                    direction: 1,
                    speed: 1,
                    pattern: 'horizontal'
                }
            };
        }

        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);
            
            // Play game over sound
            if (typeof GameSounds !== 'undefined' && GameSounds.isEnabled()) {
                GameSounds.sounds.GAME_OVER();
            }
            
            finalScoreElement.textContent = score;
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('spaceInvadersHighScore', highScore);
                highScoreElement.textContent = highScore;
            }
            
            gameOverElement.style.display = 'block';
        }

        function updateDisplay() {
            scoreElement.textContent = score;
            livesElement.textContent = lives;
            waveElement.textContent = wave;
        }

        // Keyboard controls
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    shoot();
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // Continuous movement
        setInterval(() => {
            if (!gameRunning) return;
            
            if (keys['ArrowLeft'] || keys['a'] || keys['A'] || mobileControls.leftPressed) {
                movePlayer(-1);
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D'] || mobileControls.rightPressed) {
                movePlayer(1);
            }
        }, 1000/60);

        // Initialize mobile controls
        function initMobileControls() {
            const moveLeftBtn = document.getElementById('moveLeftBtn');
            const moveRightBtn = document.getElementById('moveRightBtn');
            const shootBtn = document.getElementById('shootBtn');

            if (!moveLeftBtn || !moveRightBtn || !shootBtn) return;

            // Left movement button
            moveLeftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mobileControls.leftPressed = true;
            });
            moveLeftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                mobileControls.leftPressed = false;
            });
            moveLeftBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                mobileControls.leftPressed = true;
            });
            moveLeftBtn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                mobileControls.leftPressed = false;
            });

            // Right movement button
            moveRightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mobileControls.rightPressed = true;
            });
            moveRightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                mobileControls.rightPressed = false;
            });
            moveRightBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                mobileControls.rightPressed = true;
            });
            moveRightBtn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                mobileControls.rightPressed = false;
            });

            // Shoot button with hold-to-rapid-fire
            function startShooting() {
                if (!mobileControls.shootPressed) {
                    mobileControls.shootPressed = true;
                    shootBtn.classList.add('firing');
                    shoot(); // First shot immediately
                    
                    // Start rapid fire
                    mobileControls.shootInterval = setInterval(() => {
                        if (mobileControls.shootPressed) {
                            shoot();
                        }
                    }, mobileControls.rapidFireRate);
                }
            }

            function stopShooting() {
                mobileControls.shootPressed = false;
                shootBtn.classList.remove('firing');
                if (mobileControls.shootInterval) {
                    clearInterval(mobileControls.shootInterval);
                    mobileControls.shootInterval = null;
                }
            }

            shootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startShooting();
            });
            shootBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopShooting();
            });
            shootBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startShooting();
            });
            shootBtn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                stopShooting();
            });

            // Prevent context menu on mobile
            [moveLeftBtn, moveRightBtn, shootBtn].forEach(btn => {
                btn.addEventListener('contextmenu', (e) => e.preventDefault());
            });
        }

        // Initialize mobile controls when page loads
        document.addEventListener('DOMContentLoaded', initMobileControls);

        // Initial draw
        draw();
    </script>
    
    <!-- Sound system -->
    <script src="../../assets/js/game-sounds.js"></script>
</body>
</html>