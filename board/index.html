<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Pixel Grid 128√ó128</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: white;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #toolbar {
      margin: 10px;
      z-index: 10;
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: rgba(0,0,0,0.5);
      padding: 6px 12px;
      border-radius: 8px;
    }
    #controls {
      position: fixed;
      bottom: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 10;
    }
    button {
      background: #333;
      color: white;
      border: 1px solid #666;
      border-radius: 6px;
      padding: 8px;
      font-size: 16px;
    }
    canvas {
      background: #000;
      display: block;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="color" id="colorPicker" value="#ff0000">
  </div>
  <canvas id="pixelCanvas"></canvas>

  <!-- Mobile Controls -->
  <div id="controls">
    <button id="zoomIn">‚ûï</button>
    <button id="zoomOut">‚ûñ</button>
    <button id="panUp">‚¨ÜÔ∏è</button>
    <button id="panDown">‚¨áÔ∏è</button>
    <button id="panLeft">‚¨ÖÔ∏è</button>
    <button id="panRight">‚û°Ô∏è</button>
    <button id="resetView">üîÑ</button>
  </div>

  <script>
    const canvas = document.getElementById("pixelCanvas");
    const ctx = canvas.getContext("2d");
    const colorPicker = document.getElementById("colorPicker");

  // API routing: local dev uses the proxy, production (GitHub Pages) hits Apps Script directly
  const PROD_API = "https://script.google.com/macros/s/AKfycbyr-cmbZ_GEvPKr__TGsdL43aEI075y6vsZqy2jBa4VUy1F-ESqqFpcX-sZ1JWExFQEDA/exec";
  const IS_LOCAL = /^(localhost|127\.0\.0\.1)$/i.test(location.hostname);
  const API_URL = IS_LOCAL ? "/api/board" : PROD_API;

    // Resize canvas to window
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    }
    window.addEventListener("resize", resizeCanvas);

    // Grid data
  let grid = [];
    const gridSize = 128;

    // Viewport
    let scale = 8; // zoom factor
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let dragStart = {x:0,y:0};

    async function loadPixels() {
      try {
        const res = await fetch(API_URL);
        const data = await res.json();
        // Ensure data is a 2D array of length gridSize
        if (!Array.isArray(data) || data.length !== gridSize) throw new Error('Bad data');
        grid = data;
        draw();
      } catch (err) {
        console.error("Failed to load pixels", err);
        // Initialize a local empty grid to allow interaction offline
        if (!grid.length) {
          grid = Array.from({length: gridSize}, () => Array.from({length: gridSize}, () => "#000000"));
          draw();
        }
      }
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (!grid.length) return;
      for (let y=0; y<gridSize; y++) {
        for (let x=0; x<gridSize; x++) {
          ctx.fillStyle = grid[y][x] || "#ffffff";
          ctx.fillRect(
            x*scale + offsetX,
            y*scale + offsetY,
            scale, scale
          );
        }
      }
    }

    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragStart.x = e.clientX - offsetX;
      dragStart.y = e.clientY - offsetY;
    });

    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        offsetX = e.clientX - dragStart.x;
        offsetY = e.clientY - dragStart.y;
        draw();
      }
    });

    canvas.addEventListener("mouseup", () => { isDragging = false; });
    canvas.addEventListener("mouseleave", () => { isDragging = false; });

    // Zoom with wheel
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      scale = Math.max(2, Math.min(40, scale * zoomFactor));
      draw();
    });

    // Place pixel
    canvas.addEventListener("click", async (e) => {
      if (isDragging) return; // ignore if dragging
      const x = Math.floor((e.clientX - offsetX) / scale);
      const y = Math.floor((e.clientY - offsetY) / scale);
      if (x<0 || y<0 || x>=gridSize || y>=gridSize) return;
      const color = colorPicker.value;

      try {
        const res = await fetch(API_URL, {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({x,y,color}),
        });
        if (res.ok) {
          // Only update local grid after server confirms
          await loadPixels();
        } else {
          alert("Failed to place pixel. Server error.");
        }
      } catch (e) {
        alert("Network error: Could not place pixel.");
      }
    });

    // Touch support (dragging)
    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        isDragging = true;
        dragStart.x = e.touches[0].clientX - offsetX;
        dragStart.y = e.touches[0].clientY - offsetY;
      }
    });
    canvas.addEventListener("touchmove", (e) => {
      if (isDragging && e.touches.length === 1) {
        offsetX = e.touches[0].clientX - dragStart.x;
        offsetY = e.touches[0].clientY - dragStart.y;
        draw();
      }
    });
    canvas.addEventListener("touchend", () => { isDragging = false; });

    // Mobile buttons
    document.getElementById("zoomIn").onclick = () => { scale = Math.min(scale*1.2, 40); draw(); };
    document.getElementById("zoomOut").onclick = () => { scale = Math.max(scale*0.8, 2); draw(); };
    document.getElementById("panUp").onclick = () => { offsetY += 20; draw(); };
    document.getElementById("panDown").onclick = () => { offsetY -= 20; draw(); };
    document.getElementById("panLeft").onclick = () => { offsetX += 20; draw(); };
    document.getElementById("panRight").onclick = () => { offsetX -= 20; draw(); };
    document.getElementById("resetView").onclick = () => { offsetX=0; offsetY=0; scale=8; draw(); };

  // Auto refresh
  setInterval(loadPixels, 5000);

    resizeCanvas();
    loadPixels();
  </script>
</body>
</html>
