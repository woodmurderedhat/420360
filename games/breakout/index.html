<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout - 420360</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #330033;
            --primary: #ff3399;
            --secondary: #cc0066;
            --highlight: #ff66cc;
            --text: #ffe6f2;
            --danger: #ff0033;
            --success: #33ff99;
        }
 
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; background: var(--bg); color: var(--text); font-family: 'Press Start 2P', 'Courier New', monospace; image-rendering: pixelated; display:flex; align-items:center; justify-content:center; flex-direction:column; }
        .game-container { text-align:center; padding:20px; }
        h1 { font-size:24px; margin-bottom:20px; color:var(--primary); text-shadow:2px 2px 0 var(--secondary); }
        .game-stats { display:flex; justify-content:space-around; margin-bottom:20px; font-size:12px; color:var(--highlight); max-width:700px; }
        .stat { display:flex; flex-direction:column; align-items:center; gap:5px; }
        .stat-value { font-size:16px; color:var(--primary); }
        .game-board { border:4px solid var(--primary); box-shadow: 0 0 0 4px var(--secondary), 8px 8px 0 0 var(--highlight), 0 0 0 8px #000; background:#000; margin:0 auto 20px auto; position:relative; }
        .controls { display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin-bottom:20px; }
        .btn { background:var(--bg); border:3px solid var(--primary); color:var(--text); font-family:inherit; font-size:12px; padding:10px 20px; cursor:pointer; transition:all 0.2s; box-shadow:3px 3px 0 var(--secondary); }
        .btn:hover { background:var(--primary); color:var(--bg); transform:translate(1px,1px); box-shadow:2px 2px 0 var(--secondary); }
        .instructions { margin-top:20px; font-size:10px; line-height:1.6; max-width:600px; color:var(--text); }
        .mobile-controls { display:none; justify-content:center; gap:20px; margin-top:20px; }
        .mobile-btn { background:var(--bg); border:2px solid var(--primary); color:var(--text); font-family:inherit; font-size:14px; padding:15px 30px; cursor:pointer; transition:all 0.2s; }
        .game-message { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:var(--bg); border:4px solid var(--primary); padding:20px; text-align:center; box-shadow: 0 0 0 4px var(--secondary),8px 8px 0 0 var(--highlight); display:none; z-index:100; }
        .game-message h2 { color:var(--primary); font-size:16px; margin:0 0 10px 0; }
        .game-message p { font-size:10px; margin:10px 0; }
        .win-message { border-color:var(--success); }
        .win-message h2 { color:var(--success); }
        .lose-message { border-color:var(--danger); }
        .lose-message h2 { color:var(--danger); }
        @media (max-width:768px) { .mobile-controls { display:flex; } .instructions { font-size:8px; } h1 { font-size:18px; } .game-stats { font-size:10px; } .stat-value { font-size:14px; } }
        .header { width:100%; text-align:center; padding:15px 0; background:var(--bg); border-bottom:3px solid var(--primary); margin-bottom:20px; }
        .back-link { color:var(--primary); text-decoration:none; font-size:10px; transition:all 0.2s; display:inline-block; padding:8px 15px; border:2px solid var(--primary); background:var(--bg); box-shadow:2px 2px 0 var(--secondary); }
    </style>
</head>
<body>
    <header class="header">
        <a href="../../index.html" class="back-link" aria-label="Back to 420360.xyz Home">← Back to 420360.xyz</a>
    </header>

    <div class="game-container">
        <h1>BREAKOUT</h1>
        <div class="game-stats">
            <div class="stat"><span>SCORE</span><span class="stat-value" id="score">0</span></div>
            <div class="stat"><span>LIVES</span><span class="stat-value" id="lives">3</span></div>
            <div class="stat"><span>LEVEL</span><span class="stat-value" id="level">1</span></div>
            <div class="stat"><span>HIGH SCORE</span><span class="stat-value" id="highScore">0</span></div>
        </div>

        <div class="game-board">
            <canvas id="gameCanvas" width="700" height="520"></canvas>
            <div id="gameMessage" class="game-message"><h2 id="messageTitle">GET READY</h2><p id="messageText">Press SPACE to launch the ball</p><button class="btn" id="messageBtn">START</button></div>
        </div>

        <div class="controls">
            <button id="startBtn" class="btn">START GAME</button>
            <button id="pauseBtn" class="btn">PAUSE</button>
            <button id="resetBtn" class="btn">RESET</button>
        </div>

        <div class="mobile-controls">
            <button class="mobile-btn" id="leftTouch">← LEFT</button>
            <button class="mobile-btn" id="rightTouch">RIGHT →</button>
        </div>

        <div class="instructions">
            Use LEFT/RIGHT arrow keys or A/D to move the paddle. Break all the bricks to advance. Power-ups drop from some bricks (catch them). Press SPACE to launch the ball. Press R to reset.
        </div>
    </div>

<script>
// Canvas & constants
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const CANVAS_WIDTH = canvas.width;
const CANVAS_HEIGHT = canvas.height;

// Sizes
const PADDLE_HEIGHT = 16;
const BALL_SIZE = 12;
const BRICK_WIDTH = 60;
const BRICK_HEIGHT = 22;

// Game state
let gameRunning = false;
let gameLoop = null;
let paddleMoving = null;

// Objects
let paddle = { x: CANVAS_WIDTH/2 - 80/2, y: CANVAS_HEIGHT - 46, width: 100, height: PADDLE_HEIGHT, speed: 8, sticky: false };
let ball = { x: CANVAS_WIDTH/2, y: paddle.y - BALL_SIZE - 6, width: BALL_SIZE, height: BALL_SIZE, speedX: 4, speedY: -4, launched: false };
let bricks = [];
let powerups = []; // active falling powerups on screen
let activeEffects = {}; // timed powerups
let balls = [ball]; // support multi-ball

let score = 0;
let lives = 3;
let level = 1;
let highScore = parseInt(localStorage.getItem('breakoutHighScore') || '0', 10);

const BRICK_COLORS = ['#ff0040','#ff00ea','#fff700','#00fff7','#00ff40','#ff8000','#8000ff','#ff0080'];
const COLORS = { paddle: '#00fff7', ball:'#fff700', background:'#000' };

// Level patterns: each pattern is a grid (rows x cols) with 1/0 where 1 is brick
const PATTERNS = [
    // Full rectangle
    { rows:6, cols:10, map: (r,c,rows,cols)=>1 },
    // Checkerboard
    { rows:7, cols:10, map: (r,c)=>((r+c)%2===0?1:0) },
    // Pyramid
    { rows:8, cols:11, map: (r,c,rows)=> (c>=Math.floor((11- (rows - r))/2) && c<11-Math.floor((11- (rows - r))/2))?1:0 },
    // Staggered gaps
    { rows:6, cols:10, map: (r,c)=> (r%2===0? (c%3!==0?1:0) : (c%3===0?1:0)) },
    // Heart-ish (example custom map)
    { rows:8, cols:11, map: (r,c)=>{
        const heart = [
            '0110110',
            '1111111',
            '1111111',
            '0111110',
            '0011100'
        ];
        const hr = heart[r-1];
        if(r>=1 && r<=5){
            const pad = Math.floor((11-hr.length)/2);
            const idx = c-pad;
            return (idx>=0 && idx<hr.length && hr[idx]==='1')?1:0;
        }
        return r>5? (c>=4 && c<=6?1:0) : 0;
    } }
];
// pick an initial random pattern
function getRandomPatternIndex(exclude){
    if(typeof exclude === 'number' && PATTERNS.length <= 1) return 0;
    let idx = Math.floor(Math.random()*PATTERNS.length);
    if(typeof exclude === 'number'){
        let attempts = 0;
        while(idx === exclude && attempts < 8){ idx = Math.floor(Math.random()*PATTERNS.length); attempts++; }
    }
    return idx;
}
let patternIndex = getRandomPatternIndex();

// Powerup types
const POWERUP_TYPES = ['expand','shrink','multi','slow','life','sticky','scorex2'];

function initGame(){
    updateStats();
    createBricks();
    resetBall();
    draw();
    showMessage('GET READY','Press SPACE to launch the ball', 'START');
}

function startGame(){
    if(gameRunning){
        // restart
        resetGame();
        return;
    }
    gameRunning = true;
    hideMessage();
    if(gameLoop) clearInterval(gameLoop);
    gameLoop = setInterval(gameTick, 1000/60);
    document.getElementById('startBtn').textContent = 'RESTART';
}

function pauseGame(){
    if(!gameRunning) return;
    gameRunning = false;
    clearInterval(gameLoop);
    showMessage('PAUSED','Press START to continue','CONTINUE');
}

function resetGame(){
    score = 0; lives = 3; level = 1; patternIndex = getRandomPatternIndex(); activeEffects = {}; powerups=[]; balls = [];
    paddle.width = 100; paddle.sticky = false; balls = [ball];
    createBricks(); resetBall(); updateStats(); draw();
    if(gameLoop) clearInterval(gameLoop); gameRunning = false;
    showMessage('GET READY','Press SPACE to launch the ball','START');
}

function createBricks(){
    bricks = [];
    const pattern = PATTERNS[patternIndex % PATTERNS.length];
    const cols = pattern.cols; const rows = pattern.rows;
    const totalWidth = cols * BRICK_WIDTH;
    const offsetX = (CANVAS_WIDTH - totalWidth)/2;
    const offsetY = 50;
    for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
            const should = pattern.map(r,c,rows,cols);
            if(!should) continue;
            const color = BRICK_COLORS[r % BRICK_COLORS.length];
            bricks.push({ x: offsetX + c*BRICK_WIDTH, y: offsetY + r*BRICK_HEIGHT, width: BRICK_WIDTH-4, height: BRICK_HEIGHT-4, color, points:(rows - r)*10, destroyed:false });
        }
    }
}

function resetBall(){
    ball.x = paddle.x + paddle.width/2 - ball.width/2;
    ball.y = paddle.y - ball.height - 6;
    const speed = 4 + Math.min(level,6);
    ball.speedX = (Math.random()>0.5?1:-1) * speed;
    ball.speedY = -speed;
    ball.launched = false;
}

function gameTick(){
    if(!gameRunning) return;
    handleMovement();

    // update balls
    for(let i=0;i<balls.length;i++){
        const b = balls[i];
        if(!b.launched){ b.x = paddle.x + paddle.width/2 - b.width/2; b.y = paddle.y - b.height - 6; continue; }
        b.x += b.speedX; b.y += b.speedY;

        // wall collisions
        if(b.x <=0){ b.x=0; b.speedX = -b.speedX; }
        if(b.x + b.width >= CANVAS_WIDTH){ b.x = CANVAS_WIDTH - b.width; b.speedX = -b.speedX; }
        if(b.y <=0){ b.y=0; b.speedY = -b.speedY; }

        // paddle
        if(b.y + b.height >= paddle.y && b.y < paddle.y + paddle.height && b.x + b.width >= paddle.x && b.x <= paddle.x + paddle.width){
            // reflect depending on hit point
            const hitPoint = (b.x + b.width/2 - paddle.x) / paddle.width; // 0..1
            const angle = (hitPoint - 0.5) * Math.PI/2; // -pi/4 .. pi/4
            const speed = Math.min(8 + level*0.5, 12);
            b.speedX = Math.sin(angle) * speed;
            b.speedY = -Math.abs(Math.cos(angle) * speed);
            if(paddle.sticky){ b.launched = false; paddle.sticky = false; }
        }

        // bricks
        for(let brick of bricks){
            if(brick.destroyed) continue;
            if(b.x < brick.x + brick.width && b.x + b.width > brick.x && b.y < brick.y + brick.height && b.y + b.height > brick.y){
                brick.destroyed = true; score += brick.points; updateStats();
                // spawn powerup occasionally
                if(Math.random() < 0.12){ spawnPowerup(brick.x + brick.width/2, brick.y + brick.height/2); }

                // bounce logic: determine overlap
                const overlapX = (b.x + b.width/2) - (brick.x + brick.width/2);
                const overlapY = (b.y + b.height/2) - (brick.y + brick.height/2);
                if(Math.abs(overlapX) > Math.abs(overlapY)) b.speedX = -b.speedX; else b.speedY = -b.speedY;
                break;
            }
        }

        // bottom - ball lost
        if(b.y > CANVAS_HEIGHT){
            // remove this ball
            balls.splice(i,1); i--; 
            if(balls.length === 0){
                lives--; updateStats();
                if(lives <= 0) { gameOver(); return; }
                // reset single ball
                balls = [ { ...ball } ]; resetBall(); balls[0].launched = false; showMessage('BALL LOST', `${lives} lives remaining`, 'CONTINUE'); setTimeout(()=>hideMessage(),1500);
            }
        }
    }

    // update powerups (falling)
    for(let i=0;i<powerups.length;i++){
        const p = powerups[i];
        p.y += p.speed;
        // catch by paddle
        if(p.y + p.size >= paddle.y && p.x >= paddle.x && p.x <= paddle.x + paddle.width){
            activatePowerup(p.type); powerups.splice(i,1); i--; continue;
        }
        // fall out
        if(p.y > CANVAS_HEIGHT) { powerups.splice(i,1); i--; }
    }

    // check level complete
    if(bricks.every(b=>b.destroyed)){
    level++;
    // pick a new random pattern for next level, avoid repeating current when possible
    const old = patternIndex;
    patternIndex = getRandomPatternIndex(old);
    createBricks(); // refresh pattern
        // speed up a bit
        for(let b of balls){ b.speedX *= 1.05; b.speedY *= 1.05; }
        resetBall(); updateStats(); showMessage('LEVEL COMPLETE', `Starting Level ${level}`, 'CONTINUE'); setTimeout(()=>hideMessage(),1200);
    }

    // update active timed effects
    for(const key in activeEffects){
        const obj = activeEffects[key];
        if(obj.expiresAt && Date.now() > obj.expiresAt){
            // revert effect
            if(key === 'expand'){ paddle.width = Math.max(80, paddle.width - 40); }
            if(key === 'shrink'){ paddle.width = Math.min(120, paddle.width + 30); }
            if(key === 'slow'){ for(let b of balls){ b.speedX *= 1.25; b.speedY *= 1.25; } }
            delete activeEffects[key];
        }
    }

    draw();
}

function draw(){
    // clear
    ctx.fillStyle = COLORS.background; ctx.fillRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);
    // bricks
    bricks.forEach(brick=>{ if(!brick.destroyed){ ctx.fillStyle = brick.color; ctx.fillRect(brick.x, brick.y, brick.width, brick.height); ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.strokeRect(brick.x, brick.y, brick.width, brick.height); } });
    // paddle
    ctx.fillStyle = COLORS.paddle; ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    // balls
    for(const b of balls){ ctx.fillStyle = COLORS.ball; ctx.fillRect(b.x, b.y, b.width, b.height); }
    // powerups
    for(const p of powerups){ ctx.fillStyle = '#ffffff'; ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size); ctx.fillStyle='#000'; ctx.font='10px monospace'; ctx.fillText(p.label, p.x-6, p.y+3); }
}

let lastMessageAction = null; // controls what the message button will do when clicked

function gameOver(){
    gameRunning = false; clearInterval(gameLoop);
    if(score > highScore){
        highScore = score; localStorage.setItem('breakoutHighScore', highScore.toString()); updateStats();
        showWinMessage('NEW HIGH SCORE!', `Final Score: ${score}`);
        lastMessageAction = 'restart';
    } else {
        showLoseMessage('GAME OVER', `Final Score: ${score}`);
        lastMessageAction = 'restart';
    }
}

function updateStats(){ document.getElementById('score').textContent = score; document.getElementById('lives').textContent = lives; document.getElementById('level').textContent = level; document.getElementById('highScore').textContent = highScore; }

function showMessage(title,text,btnText=''){
    lastMessageAction = null;
    document.getElementById('messageTitle').textContent = title;
    document.getElementById('messageText').textContent = text;
    const gm = document.getElementById('gameMessage'); gm.className='game-message';
    document.getElementById('messageBtn').textContent = btnText || 'OK'; gm.style.display='block';
}
function showWinMessage(title,text){
    lastMessageAction = 'restart';
    document.getElementById('messageTitle').textContent = title;
    document.getElementById('messageText').textContent = text;
    const gm=document.getElementById('gameMessage'); gm.className='game-message win-message';
    document.getElementById('messageBtn').textContent='PLAY AGAIN'; gm.style.display='block';
}
function showLoseMessage(title,text){
    lastMessageAction = 'restart';
    document.getElementById('messageTitle').textContent = title;
    document.getElementById('messageText').textContent = text;
    const gm=document.getElementById('gameMessage'); gm.className='game-message lose-message';
    document.getElementById('messageBtn').textContent='RESTART'; gm.style.display='block';
}
function hideMessage(){ document.getElementById('gameMessage').style.display='none'; }

function spawnPowerup(x,y){ const type = POWERUP_TYPES[Math.floor(Math.random()*POWERUP_TYPES.length)]; const label = {expand:'E',shrink:'s',multi:'M',slow:'S',life:'L',sticky:'T',scorex2:'x2'}[type]||'?'; powerups.push({ x, y, type, size:18, label, speed:2 }); }

function activatePowerup(type){ switch(type){
    case 'expand': paddle.width = Math.min(180, paddle.width + 40); activeEffects['expand'] = { expiresAt: Date.now() + 12000 }; break;
    case 'shrink': paddle.width = Math.max(60, paddle.width - 30); activeEffects['shrink'] = { expiresAt: Date.now() + 10000 }; break;
    case 'multi': // duplicate current balls
        const clones = [];
        for(const b of balls){ clones.push({ ...b, speedX: -b.speedX, speedY: b.speedY, launched:true }); }
        balls = balls.concat(clones); break;
    case 'slow': for(const b of balls){ b.speedX *= 0.6; b.speedY *= 0.6; } activeEffects['slow'] = { expiresAt: Date.now() + 10000 }; break;
    case 'life': lives++; break;
    case 'sticky': paddle.sticky = true; activeEffects['sticky'] = { expiresAt: Date.now() + 10000 }; break;
    case 'scorex2': score *= 2; break; }
    updateStats(); }

// Movement
let keys = {};
document.addEventListener('keydown',(e)=>{ keys[e.key]=true; if(e.key===' '){ e.preventDefault(); // space
    if(!balls.some(b=>b.launched)){
        // launch all balls
        for(const b of balls){ b.launched = true; }
        if(!gameRunning) startGame();
    } else if(!gameRunning){ startGame(); }
 }
 if(e.key==='r' || e.key==='R'){ e.preventDefault(); resetGame(); }
});
document.addEventListener('keyup',(e)=>{ keys[e.key]=false; });

function handleMovement(){ if(keys['a']||keys['A']||keys['ArrowLeft']){ paddle.x = Math.max(0, paddle.x - paddle.speed); }
 if(keys['d']||keys['D']||keys['ArrowRight']){ paddle.x = Math.min(CANVAS_WIDTH - paddle.width, paddle.x + paddle.speed); } }
setInterval(handleMovement, 1000/60);

// Touch controls
const leftTouch = document.getElementById('leftTouch'); const rightTouch = document.getElementById('rightTouch');
leftTouch.addEventListener('touchstart',()=>paddleMoving='left'); leftTouch.addEventListener('touchend',()=>paddleMoving=null);
rightTouch.addEventListener('touchstart',()=>paddleMoving='right'); rightTouch.addEventListener('touchend',()=>paddleMoving=null);
leftTouch.addEventListener('mousedown',()=>paddleMoving='left'); leftTouch.addEventListener('mouseup',()=>paddleMoving=null);
rightTouch.addEventListener('mousedown',()=>paddleMoving='right'); rightTouch.addEventListener('mouseup',()=>paddleMoving=null);

// continuous paddle movement when touch buttons pressed
setInterval(()=>{ if(paddleMoving==='left') paddle.x = Math.max(0, paddle.x - paddle.speed); if(paddleMoving==='right') paddle.x = Math.min(CANVAS_WIDTH - paddle.width, paddle.x + paddle.speed); },1000/60);

// UI bindings
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('pauseBtn').addEventListener('click', pauseGame);
document.getElementById('resetBtn').addEventListener('click', resetGame);
document.getElementById('messageBtn').addEventListener('click', ()=>{
    const action = lastMessageAction;
    hideMessage();
    if(action === 'restart'){
        // full restart then start
        resetGame();
        startGame();
        lastMessageAction = null;
        return;
    }
    if(!gameRunning) startGame();
});
// init
initGame();
</script>
</body>
</html>
